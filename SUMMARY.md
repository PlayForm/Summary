Entry: 
 .
Summary: 
 {17195345885754272243: ("diff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n", "üó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:"), 16097180198974362790: ("diff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n", "üó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:"), 377108715356394484: ("diff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..c3006f1 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,40 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P > SUMMARY.md\n```\n\n[Summary] will now generate the following [SUMMARY.md](./SUMMARY.md) for all the\ncommits and tags between the first and the last commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +43,134 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories.\n\nDefault is:\n\n```sh\nSummary\nSummary -E node_modules\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing.\n\nDefault is:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\nSummary \\\n\t--Omit \"Target\" \\\n\t--Omit \"target\" \\\n\t--Omit \"Documentation\" \\\n\t--Omit \"documentation\" \\\n\t--Omit \"SUMMARY.md\" \\\n\t--Omit \"CHANGELOG.md\" \\\n\t--Omit \"summary.md\" \\\n\t--Omit \"changelog.md\"\n```\n\n## Options\n#### --Parallel or -P:\n\nRun processing in parallel.\n\nDefault is:\n\n```sh\nSummary\n```\n\n#### --Pattern:\n\nSpecify a custom pattern for matching.\n\nDefault is:\n\n```sh\nSummary --Pattern .git\n```\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\nSet the current working directory to a different folder.\n\nDefault is:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary --Root .\n```\n\n#### --Parallel or -P:\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\nOmit specific file patterns:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..fbdff71 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,82 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\n\t\t\t\t\t\"Target\",\n\t\t\t\t\t\"target\",\n\t\t\t\t\t\"Documentation\",\n\t\t\t\t\t\"documentation\",\n\t\t\t\t\t\"SUMMARY.md\",\n\t\t\t\t\t\"CHANGELOG.md\",\n\t\t\t\t\t\"summary.md\",\n\t\t\t\t\t\"changelog.md\",\n\t\t\t\t]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..387c0e4\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..75ef690\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,51 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..a84435b\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,44 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..f199ca3\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,84 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Errors\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..544095b\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,18 @@\n#![allow(non_snake_case)]\n//! The main entry point for the Summary application.\n\nmod Fn;\nmod Struct;\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..7473837\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,48 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..ee24305\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,41 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\tpub Entry: Type,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..3f069ff\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,55 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Root: String,\n\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..bb7ec8e\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..3d4e06d\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,15242 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..2411611 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f600aa6\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,2897 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\ndiff --git a/Summary.md b/Summary.md\nindex f600aa6..f74c21e 100644\n--- a/Summary.md\n+++ b/Summary.md\n@@ -1,3 +1,1121 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,97 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```sh\nSummary\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\nSpecify a custom pattern for matching (defailt is `.git`).\n## Options\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,39 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -44,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -63,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n@@ -1067,149 +2185,7 @@ index 0000000..7241509\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.5:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n@@ -1243,10 +2219,10 @@ struct Toml {\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\nindex 3e65019..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\n@@ -11,9 +11,10 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\n@@ -1258,20 +2234,15 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\nindex 871c006..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n@@ -1354,7 +2325,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\"Documentation\").\n\n#### --Parallel or -P:\n\n@@ -1697,10 +2668,10 @@ pub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\nindex 0000000..ae3e650\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n@@ -0,0 +1,49 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n@@ -1714,12 +2685,10 @@ index 0000000..0e302ee\n/// # Example\n///\n/// ```\n/// let Option = Option {\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -1731,52 +2700,17 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -1787,7 +2721,6 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n@@ -1916,32 +2849,6 @@ pub fn Fn(\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n@@ -2302,9 +3209,29 @@ index 0000000..7241509\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.5 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n@@ -2353,6 +3280,15 @@ The [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n@@ -2509,10 +3445,10 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\nindex ae3e650..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n@@ -2527,50 +3463,84 @@ index 0e302ee..f199ca3 100644\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let Option = Option {\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n@@ -2707,29 +3677,37 @@ pub fn Fn(\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.7:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,40 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +43,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\nThe Summary tool can be used with various options:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,73 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..387c0e4\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..75ef690\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,51 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..a84435b\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,44 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..f199ca3\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,84 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Errors\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..544095b\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,18 @@\n#![allow(non_snake_case)]\n//! The main entry point for the Summary application.\n\nmod Fn;\nmod Struct;\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..7473837\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,48 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..ee24305\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,41 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\tpub Entry: Type,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..3f069ff\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,55 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Root: String,\n\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..bb7ec8e\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f74c21e\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,3875 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,97 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```sh\nSummary\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\nSpecify a custom pattern for matching (defailt is `.git`).\n## Options\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,39 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -44,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -63,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.5:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,9 +11,10 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..ae3e650\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,49 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.5 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.7 to last commit:\ndiff --git a/README.md b/README.md\nindex d388d49..22a46bb 100644\n--- a/README.md\n+++ b/README.md\n@@ -7,11 +7,11 @@ processing capabilities, along with flexible file filtering options.\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\nSummary -P -O Target -O target -O SUMMARY.md -O CHANGELOG.md > SUMMARY.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n[Summary] will now generate the following [SUMMARY.md](./SUMMARY.md) for all the\ncommits and tags between the first and the last commit.\n\n## Features\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..1324482 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -32,7 +32,14 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t\t\t.default_values([\n\t\t\t\t\t\"Target\",\n\t\t\t\t\t\"target\",\n\t\t\t\t\t\"Documentation\",\n\t\t\t\t\t\"documentation\",\n\t\t\t\t\t\"SUMMARY.md\",\n\t\t\t\t\t\"CHANGELOG.md\",\n\t\t\t\t]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Summary.md b/Summary.md\ndeleted file mode 100644\nindex f74c21e..0000000\n--- a/Summary.md\n+++ /dev/null\n@@ -1,3875 +0,0 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,97 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```sh\nSummary\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\nSpecify a custom pattern for matching (defailt is `.git`).\n## Options\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,39 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -44,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -63,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.5:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,9 +11,10 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..ae3e650\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,49 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.5 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\n", "üó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.7:"), 1817754920059548089: ("diff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n", "üó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:"), 44685073801500370: ("diff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..2411611 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f600aa6\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,2897 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n", "üó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:"), 17471858301966271134: ("diff --git a/Summary.md b/Summary.md\nindex 3d4e06d..9b5ce52 100644\n--- a/Summary.md\n+++ b/Summary.md\n@@ -1,3 +1,1116 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex c3006f1..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P > SUMMARY.md\n```\n\n[Summary] will now generate the following [SUMMARY.md](./SUMMARY.md) for all the\ncommits and tags between the first and the last commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,134 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories.\n\nDefault is:\n\n```sh\nSummary -E node_modules\n```\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing.\n\nDefault is:\n\n```sh\nSummary \\\n\t--Omit \"Target\" \\\n\t--Omit \"target\" \\\n\t--Omit \"Documentation\" \\\n\t--Omit \"documentation\" \\\n\t--Omit \"SUMMARY.md\" \\\n\t--Omit \"CHANGELOG.md\" \\\n\t--Omit \"summary.md\" \\\n\t--Omit \"changelog.md\"\n```\n\n#### --Parallel or -P:\n\nRun processing in parallel.\n\nDefault is:\n\n```sh\nSummary\n```\n\n#### --Pattern:\n\nSpecify a custom pattern for matching.\n\nDefault is:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\n```sh\nSummary --Pattern .git\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\n#### --Root or -R:\n## Options\n\nSet the current working directory to a different folder.\n#### --Root or -R:\n\nDefault is:\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary --Root .\nSummary -R D:\\Developer .git git fetch upstream\n```\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex fbdff71..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,48 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\n\t\t\t\t\t\"Target\",\n\t\t\t\t\t\"target\",\n\t\t\t\t\t\"Documentation\",\n\t\t\t\t\t\"documentation\",\n\t\t\t\t\t\"SUMMARY.md\",\n\t\t\t\t\t\"CHANGELOG.md\",\n\t\t\t\t\t\"summary.md\",\n\t\t\t\t\t\"changelog.md\",\n\t\t\t\t]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -53,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -72,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\ndiff --git a/Summary.md b/Summary.md\ndeleted file mode 100644\nindex 3d4e06d..0000000\n--- a/Summary.md\n+++ /dev/null\n@@ -1,15242 +0,0 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n@@ -15240,3 +16353,11709 @@ pub struct Struct {\n}\n\n\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..2411611 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f600aa6\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,2897 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,40 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +43,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\nThe Summary tool can be used with various options:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,73 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..387c0e4\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..75ef690\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,51 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..a84435b\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,44 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..2411611\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,84 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Errors\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..544095b\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,18 @@\n#![allow(non_snake_case)]\n//! The main entry point for the Summary application.\n\nmod Fn;\nmod Struct;\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..7473837\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,48 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..ee24305\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,41 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\tpub Entry: Type,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..3f069ff\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,55 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Root: String,\n\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..bb7ec8e\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f600aa6\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,2897 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..c3006f1 100644\n--- a/README.md\n+++ b/README.md\n@@ -7,11 +7,11 @@ processing capabilities, along with flexible file filtering options.\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\nSummary -P > SUMMARY.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n[Summary] will now generate the following [SUMMARY.md](./SUMMARY.md) for all the\ncommits and tags between the first and the last commit.\n\n## Features\n\n@@ -69,24 +69,61 @@ The [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\nExclude certain files or directories.\n\nDefault is:\n\n```sh\nSummary -E node_modules\n```\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\nSpecify regex patterns to omit files from processing.\n\nDefault is:\n\n```sh\nSummary \\\n\t--Omit \"Target\" \\\n\t--Omit \"target\" \\\n\t--Omit \"Documentation\" \\\n\t--Omit \"documentation\" \\\n\t--Omit \"SUMMARY.md\" \\\n\t--Omit \"CHANGELOG.md\" \\\n\t--Omit \"summary.md\" \\\n\t--Omit \"changelog.md\"\n```\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\nRun processing in parallel.\n\nDefault is:\n\n```sh\nSummary\n```\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\nSpecify a custom pattern for matching.\n\nDefault is:\n\n```sh\nSummary --Pattern .git\n```\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\nSet the current working directory to a different folder.\n\nDefault is:\n\n```sh\nSummary --Root .\n```\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..fbdff71 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -32,7 +32,16 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t\t\t.default_values([\n\t\t\t\t\t\"Target\",\n\t\t\t\t\t\"target\",\n\t\t\t\t\t\"Documentation\",\n\t\t\t\t\t\"documentation\",\n\t\t\t\t\t\"SUMMARY.md\",\n\t\t\t\t\t\"CHANGELOG.md\",\n\t\t\t\t\t\"summary.md\",\n\t\t\t\t\t\"changelog.md\",\n\t\t\t\t]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\ndiff --git a/Summary.md b/Summary.md\ndeleted file mode 100644\nindex f600aa6..0000000\n--- a/Summary.md\n+++ /dev/null\n@@ -1,2897 +0,0 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\n", "üó£\u{fe0f} Summary from latest tag: Summary/v0.0.7 to last commit:"), 9454414688498605510: ("diff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..c3006f1 100644\n--- a/README.md\n+++ b/README.md\n@@ -7,11 +7,11 @@ processing capabilities, along with flexible file filtering options.\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\nSummary -P > SUMMARY.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n[Summary] will now generate the following [SUMMARY.md](./SUMMARY.md) for all the\ncommits and tags between the first and the last commit.\n\n## Features\n\n@@ -69,24 +69,61 @@ The [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\nExclude certain files or directories.\n\nDefault is:\n\n```sh\nSummary -E node_modules\n```\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\nSpecify regex patterns to omit files from processing.\n\nDefault is:\n\n```sh\nSummary \\\n\t--Omit \"Target\" \\\n\t--Omit \"target\" \\\n\t--Omit \"Documentation\" \\\n\t--Omit \"documentation\" \\\n\t--Omit \"SUMMARY.md\" \\\n\t--Omit \"CHANGELOG.md\" \\\n\t--Omit \"summary.md\" \\\n\t--Omit \"changelog.md\"\n```\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\nRun processing in parallel.\n\nDefault is:\n\n```sh\nSummary\n```\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\nSpecify a custom pattern for matching.\n\nDefault is:\n\n```sh\nSummary --Pattern .git\n```\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\nSet the current working directory to a different folder.\n\nDefault is:\n\n```sh\nSummary --Root .\n```\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..fbdff71 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -32,7 +32,16 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t\t\t.default_values([\n\t\t\t\t\t\"Target\",\n\t\t\t\t\t\"target\",\n\t\t\t\t\t\"Documentation\",\n\t\t\t\t\t\"documentation\",\n\t\t\t\t\t\"SUMMARY.md\",\n\t\t\t\t\t\"CHANGELOG.md\",\n\t\t\t\t\t\"summary.md\",\n\t\t\t\t\t\"changelog.md\",\n\t\t\t\t]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\ndiff --git a/Summary.md b/Summary.md\nindex f600aa6..3d4e06d 100644\n--- a/Summary.md\n+++ b/Summary.md\n@@ -1079,6 +1079,1745 @@ serde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..2411611 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f600aa6\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,2897 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\n@@ -2895,3 +4634,10609 @@ pub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\ndiff --git a/Summary.md b/Summary.md\nindex f600aa6..f74c21e 100644\n--- a/Summary.md\n+++ b/Summary.md\n@@ -1,3 +1,1121 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,97 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```sh\nSummary\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\nSpecify a custom pattern for matching (defailt is `.git`).\n## Options\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,39 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -44,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -63,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n@@ -1067,149 +2185,7 @@ index 0000000..7241509\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.5 to tag: Summary/v0.0.6:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..7c5b90e 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.6\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..786f795 100644\n--- a/README.md\n+++ b/README.md\n@@ -67,7 +67,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..0e302ee 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -11,10 +11,12 @@\n/// # Example\n///\n/// ```\n/// let option = Option {\n/// let Option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n///\n/// let summary = Fn(&Option);\n///\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -26,17 +28,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +84,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.6:\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.5:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n@@ -1243,10 +2219,10 @@ struct Toml {\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..7c5b90e 100644\nindex 3e65019..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\n@@ -11,9 +11,10 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\n@@ -1258,20 +2234,15 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.6\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..786f795 100644\nindex 871c006..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n@@ -1354,7 +2325,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\"Documentation\").\n\n#### --Parallel or -P:\n\n@@ -1697,10 +2668,10 @@ pub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..0e302ee\nindex 0000000..ae3e650\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,87 @@\n@@ -0,0 +1,49 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n@@ -1714,12 +2685,10 @@ index 0000000..0e302ee\n/// # Example\n///\n/// ```\n/// let Option = Option {\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n///\n/// let summary = Fn(&Option);\n///\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(\n\tEntry: &str,\n@@ -1731,52 +2700,17 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -1787,7 +2721,6 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n@@ -1916,32 +2849,6 @@ pub fn Fn(\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..7bfdeee\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,20 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n@@ -2302,9 +3209,29 @@ index 0000000..7241509\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.6 to last commit:\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.5 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 786f795..d388d49 100644\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n@@ -2353,6 +3280,15 @@ The [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n@@ -2509,10 +3445,10 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 0e302ee..f199ca3 100644\nindex ae3e650..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,23 +1,20 @@\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n@@ -2527,50 +3463,84 @@ index 0e302ee..f199ca3 100644\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let Option = Option {\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// let summary = Fn(&Option);\n/// # Errors\n///\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -35,7 +32,7 @@ pub async fn Fn(\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to last commit: {}:\", First, Last);\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n@@ -55,14 +52,14 @@ pub async fn Fn(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit: {} to latest tag: {}:\", First, Latest);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit: {}:\", Latest, Last);\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n@@ -2707,29 +3677,37 @@ pub fn Fn(\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nindex 7bfdeee..a0c3df6 100644\n--- a/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -1,10 +1,16 @@\n/// Function to iterate over the commits in a repository in reverse topological order.\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n/// * `Repository` - A reference to the repository to iterate over.\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n/// * Result containing the next commit in the iteration or an error if no commits are found.\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.7:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,13 +11,14 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,40 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +43,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\nThe Summary tool can be used with various options:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,73 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..387c0e4\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..75ef690\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,51 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..a84435b\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,44 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Async\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..f199ca3\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,84 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Errors\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..544095b\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,18 @@\n#![allow(non_snake_case)]\n//! The main entry point for the Summary application.\n\nmod Fn;\nmod Struct;\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..7473837\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,48 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..ee24305\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,41 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\tpub Entry: Type,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..3f069ff\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,55 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\tpub Parallel: Parallel,\n\n\tpub Pattern: Pattern,\n\n\tpub Root: String,\n\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..bb7ec8e\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\ndiff --git a/Summary.md b/Summary.md\nnew file mode 100644\nindex 0000000..f74c21e\n--- /dev/null\n+++ b/Summary.md\n@@ -0,0 +1,3875 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,97 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```sh\nSummary\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\nSpecify a custom pattern for matching (defailt is `.git`).\n## Options\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,39 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -44,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -63,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.5:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,9 +11,10 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..ae3e650\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,49 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.5 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.7 to last commit:\ndiff --git a/README.md b/README.md\nindex d388d49..22a46bb 100644\n--- a/README.md\n+++ b/README.md\n@@ -7,11 +7,11 @@ processing capabilities, along with flexible file filtering options.\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\nSummary -P -O Target -O target -O SUMMARY.md -O CHANGELOG.md > SUMMARY.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n[Summary] will now generate the following [SUMMARY.md](./SUMMARY.md) for all the\ncommits and tags between the first and the last commit.\n\n## Features\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..1324482 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -32,7 +32,14 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t\t\t.default_values([\n\t\t\t\t\t\"Target\",\n\t\t\t\t\t\"target\",\n\t\t\t\t\t\"Documentation\",\n\t\t\t\t\t\"documentation\",\n\t\t\t\t\t\"SUMMARY.md\",\n\t\t\t\t\t\"CHANGELOG.md\",\n\t\t\t\t]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Summary.md b/Summary.md\ndeleted file mode 100644\nindex f74c21e..0000000\n--- a/Summary.md\n+++ /dev/null\n@@ -1,3875 +0,0 @@\nüó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 7c5b90e..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.6\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex 2411611..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -35,7 +35,7 @@ pub async fn Fn(\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n@@ -46,7 +46,7 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n@@ -55,14 +55,14 @@ pub async fn Fn(\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"```\\n{}\\n```\",\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.7 to tag: Summary/v0.0.1:\ndiff --git a/build.rs b/build.rs\nindex 1f0de60..73ccc94 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,5 +1,8 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -21,6 +24,3 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c907ec5..745ad03 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,10 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.17\"\ntoml = \"0.8.16\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.7\"\nversion = \"0.0.1\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex d388d49..fd4bfe5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,40 +1,11 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -43,97 +14,58 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```sh\nSummary\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\n\nSpecify regex patterns to omit files from processing (default is\n`Documentation`).\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n\nSpecify a custom pattern for matching (defailt is `.git`).\n## Options\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\n\n## Examples\n#### --Parallel or -P:\n\nAnalyze the current directory:\nSummary commands in `parallel` (default is `sequential`):\n\n```sh\nSummary\nSummary -P -R D:\\Developer .git git fetch upstream\n```\n\nAnalyze a specific directory in parallel:\n#### --Exclude:\n\n```sh\nSummary -P -R D:\\Developer\n```\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n\nExclude additional directories:\n#### --Pattern:\n\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\nSpecify a custom pattern for matching (defailt is `.git`)\n\nOmit specific file patterns:\n#### --Separator:\n\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\nDefine a custom separator\n\n## Dependencies\n\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n`Summary` relies on several Rust crates to provide its functionality:\n\n[Pieces OS] For extended functionality and system integration.\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e355a33..c590122 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,39 +1,21 @@\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -44,15 +26,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -63,6 +36,24 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 387c0e4..64351c7 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,14 +1,29 @@\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A reference to an Option struct containing processing parameters.\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// Returns a vector of processed entries.\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 75ef690..37a5949 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,20 +1,24 @@\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -25,27 +29,22 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.collect()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex a84435b..63923f7 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,16 +1,23 @@\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing various options for execution.\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Async\n/// # Example\n///\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\tEntry\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n@@ -19,26 +26,9 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f199ca3..eb2d2ce 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,77 +1,44 @@\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n/// * `Return` - The generated summary.\n///\n/// # Errors\n/// # Example\n///\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\n\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t\tStart = Some(Tag);\n\t\t}\n\t}\n\n@@ -79,6 +46,10 @@ pub async fn Fn(\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod First;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 544095b..8d7badf 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,122 +1,33 @@\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\ndeleted file mode 100644\nindex a0c3df6..0000000\n--- a/Source/Fn/Summary/First.rs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\nnew file mode 100644\nindex 0000000..611f1eb\n--- /dev/null\n+++ b/Source/Fn/Summary/Release.rs\n@@ -0,0 +1,33 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 7b297ec..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,13 +1,9 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n/// The main entry point for the Summary application.\n///\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 7473837..da03f34 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,23 +1,12 @@\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The separator used for file paths.\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -30,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n@@ -39,10 +28,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex ee24305..c0c6b89 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,32 +1,22 @@\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -34,8 +24,7 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 3f069ff..8453d33 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,55 +1,42 @@\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\tExclude: Fn()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex 4ca5f2b..a56e8ce 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1,2 +1 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\ndeleted file mode 100644\nindex bb7ec8e..0000000\n--- a/Source/Struct/Summary/Difference.rs\n+++ /dev/null\n@@ -1,6 +0,0 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\ndeleted file mode 100644\nindex 7241509..0000000\n--- a/Source/Struct/Summary/mod.rs\n+++ /dev/null\n@@ -1 +0,0 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.1 to tag: Summary/v0.0.2:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 745ad03..c769c35 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -34,5 +34,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.2\"\nedition = \"2021\"\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.2 to tag: Summary/v0.0.3:\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c769c35..c10016a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,6 +14,7 @@ rayon = \"1.10.0\"\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.2\"\nversion = \"0.0.3\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex fd4bfe5..018729b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n\n## Pieces OS Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\n\n## Installation\n\n```sh\n@@ -14,6 +36,18 @@ cargo install psummary\n\n## Usage\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\n\n```sh\nSummary\n```\n@@ -60,10 +94,13 @@ Define a custom separator\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `rayon` - For parallel processing.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex c590122..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -16,6 +16,27 @@ pub fn Fn() -> ArgMatches {\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n@@ -26,6 +47,15 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n@@ -36,24 +66,6 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.get_matches()\n}\n\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 37a5949..463f890 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -17,8 +17,8 @@\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\tlet Queue: Vec<_> = stream::iter(\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -29,20 +29,21 @@ pub async fn Fn(Option { Entry, Separator, Pattern, .. }: Option) {\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| async move {\n\t\tmatch crate::Fn::Summary::Fn(&Entry).await {\n\t\t\tOk(summary) => Ok(summary),\n\t\t\tErr(e) => Err(format!(\"Error generating summary for {}: {}\", Entry, e)),\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect()\n\t.collect::<Vec<_>>()\n\t.await;\n\n\tQueue.par_iter().for_each(|Output| match Output {\n\t\tOk(Summary) => println!(\"Summary: {:?}\", Summary),\n\t\tErr(Error) => eprintln!(\"Error: {}\", Error),\n\t});\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 63923f7..c19801b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -17,7 +17,8 @@\n/// };\n/// Fn(option);\n/// ```\npub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -26,9 +27,25 @@ pub fn Fn(Option { Entry, Pattern, Separator, .. }: Option) {\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t.for_each(|_Entry| {\n\t\t\t// TODO: GENERATE SUMMARY\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex eb2d2ce..f6825a8 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -16,29 +16,28 @@\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n\tlet Repository = Repository::open(Entry)?;\n\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\tlet mut Start = None;\n\n\tlet Summary = \"Summary\";\n\tfs::create_dir_all(Summary)?;\n\n\tfor i in 0..Tag.len() {\n\t\tif let Some(Tag) = Tag.get(i) {\n\t\t\tif let Some(Start) = Start {\n\t\t\t\tlet Difference = crate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?;\n\n\t\t\t\tFile::create(&format!(\"{}/Difference_{}_{}.txt\", Summary, Start, Tag))?.write_all(\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, Tag)?.as_bytes(),\n\t\t\t\t)?;\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\t\tFile::create(&format!(\"{}/Release_{}_{}.txt\", Summary, Start, Tag))?\n\t\t\t\t\t.write_all(crate::Fn::Summary::Release::Fn(&Difference).as_bytes())?;\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tStart = Some(Tag);\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n@@ -46,10 +45,5 @@ pub async fn Fn(Entry: &str) -> Result<(), Box<dyn std::error::Error>> {\n}\n\nuse git2::Repository;\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n};\n\npub mod Difference;\npub mod Release;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 8d7badf..4951c08 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -16,18 +16,61 @@\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(Repo: &git2::Repository, Start: &str, End: &str) -> Result<String, git2::Error> {\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\tRepo.diff_tree_to_tree(\n\t\tSome(&Repo.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\tSome(&Repo.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\tSome(&mut git2::DiffOptions::new()),\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tDifference.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Fn/Summary/Release.rs b/Source/Fn/Summary/Release.rs\ndeleted file mode 100644\nindex 611f1eb..0000000\n--- a/Source/Fn/Summary/Release.rs\n+++ /dev/null\n@@ -1,33 +0,0 @@\n/// Generates a release summary.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the release summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated release summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for release summary generation\n/// };\n/// let release_summary = Fn(&option);\n/// ```\npub fn Fn(Difference: &str) -> String {\n\tlet mut Release = String::new();\n\n\tRelease.push_str(\"Release Notes:\\n\");\n\n\tfor Difference in Difference.lines() {\n\t\tif Difference.starts_with(\"+\") && !Difference.starts_with(\"+++\") {\n\t\t\tRelease.push_str(&format!(\"Added: {}\\n\", &Difference[1..]));\n\t\t} else if Difference.starts_with(\"-\") && !Difference.starts_with(\"---\") {\n\t\t\tRelease.push_str(&format!(\"Removed: {}\\n\", &Difference[1..]));\n\t\t}\n\t}\n\n\tRelease\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex da03f34..4a356ae 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -19,7 +19,7 @@ impl Struct {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option);\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex c0c6b89..45d3e41 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -11,12 +11,16 @@ pub struct Struct {\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n@@ -24,7 +28,9 @@ impl Struct {\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{Parallel, Pattern, Separator, Struct as Option};\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8453d33..8d32f31 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -3,6 +3,9 @@ pub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n@@ -20,23 +23,29 @@ impl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Fn()\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Command| Command.to_string())\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Fn().get_flag(\"Parallel\"),\n\t\t\tPattern: Fn().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Fn().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn, Struct::Binary::Command::Struct as Option};\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.3 to tag: Summary/v0.0.4:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c10016a..3d3159a 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.3\"\nversion = \"0.0.4\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 018729b..49bf9ea 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,32 +1,32 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient file processing\nand summarization. It offers both sequential and parallel processing\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Feature\n## Features\n\n-   Directory traversal and file filtering\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   Integration with Pieces OS for enhanced functionality\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n\n## Pieces OS Integration\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports Pieces OS, essentially acting as a plugin that can\nrewrite the whole system. This integration allows for:\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Enhanced code analysis and summarization.\n-   Improved context-aware processing.\n-   Seamless integration with other Pieces OS-compatible tools.\n-   Potential for AI-driven insights and optimizations.\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging Pieces OS, `Summary` can tap into a broader ecosystem of\ndevelopment tools and services, significantly expanding its capabilities beyond\nbasic file processing.\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n@@ -36,73 +36,97 @@ cargo install psummary\n\n## Usage\n\nThe Summary tool can be used with various options:\n\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n-   `--Root` or `-R`: Set the current working directory\n-   `--Parallel` or `-P`: Run commands in parallel\n-   `--Exclude`: Exclude certain files or directories\n-   `--Pattern`: Specify a custom pattern for matching\n-   `--Separator`: Define a custom separator\n#### --Exclude or -E:\n\nFor Pieces OS integration, refer to the Pieces OS documentation for specific\nflags and configuration options.\n[Pieces](HTTPS://GitHub.Com/PlayForm/Pieces.git)\nExclude certain files or directories (defailt is `node_modules`).\n\n```sh\nSummary\n```\n#### --Omit or -O:\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\n#### --Parallel or -P:\n\n## Options\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\n```\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n#### --Parallel or -P:\n## Examples\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze the current directory:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Exclude:\nAnalyze a specific directory in parallel:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -P -R D:\\Developer\n```\n\n#### --Pattern:\nExclude additional directories:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Separator:\nOmit specific file patterns:\n\nDefine a custom separator\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS](HTTPS://Pieces.App): For extended functionality and system\nintegration.\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex 4951c08..d96794d 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -25,16 +25,6 @@ pub fn Fn(\n\tlet mut Difference = String::new();\n\tlet mut Options = git2::DiffOptions::new();\n\n\t// Options.pathspec(\n\t// \tstd::ffi::CString::new(\n\t// \t\tstd::iter::once(\"*\".to_string())\n\t// \t\t\t.chain(Option.Omit.iter().map(|Omit| format!(\"{}\", Omit)))\n\t// \t\t\t.collect::<Vec<String>>()\n\t// \t\t\t.join(\"\\0\"),\n\t// \t)\n\t// \t.expect(\"Cannot create CString\"),\n\t// );\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\nüó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from first commit to latest tag: Summary/v0.0.5:\ndiff --git a/.gitignore b/.gitignore\nindex 34f0334..619d2a9 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -5,5 +5,5 @@\n\n!/Target/release/*.deb\n!/Target/release/*.exe\n!/Target/release/PRun\n!/Target/release/Run\n!/Target/release/PSummary\n!/Target/release/Summary\ndiff --git a/build.rs b/build.rs\nindex 73ccc94..1f0de60 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,5 @@\n#![allow(non_snake_case)]\n\nuse serde::Deserialize;\nuse std::fs;\n\n#[derive(Deserialize)]\nstruct Toml {\n\tpackage: Package,\n@@ -24,3 +21,6 @@ fn main() {\n\t\t.version\n\t);\n}\n\nuse serde::Deserialize;\nuse std::fs;\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3e65019..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,9 +11,10 @@ clap = { features = [\"derive\"], version = \"4.5.11\" }\nwalkdir = \"2.5.0\"\nfutures = \"0.3.30\"\nrayon = \"1.10.0\"\ntokio = { version = \"1.39.1\", features = [\"full\"] }\ntokio = { version = \"1.39.2\", features = [\"full\"] }\ngit2 = { version = \"0.19.0\" }\nnum_cpus = \"1.16.0\"\nregex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\n@@ -34,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.1\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 871c006..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,33 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a command-line tool that executes commands in multiple directories\nsimultaneously. It leverages parallel processing and concurrent `I/O` to\nefficiently run tasks across directories.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n\n```sh\n@@ -14,54 +36,97 @@ cargo install psummary\n\n## Usage\n\n```sh\nSummary\n```\n\nThis command will fetch from upstream for all `.git` repositories inside the\ncurrent directory. It essentially replaces the following command:\nThe Summary tool can be used with various options:\n\n```sh\nfind -iname .git -type d -execdir git fetch upstream \\;\n```\nüó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\n\nUsage: Summary [OPTIONS]\n\nOptions:\n  -P, --Parallel           ‚è©\u{2001}Parallel\u{2001}‚Äî\n  -R, --Root <ROOT>        üìÇ\u{2001}Root\u{2001}‚Äî [default: .]\n  -E, --Exclude <EXCLUDE>  üö´\u{2001}Exclude\u{2001}‚Äî [default: node_modules]\n      --Pattern <PATTERN>  üîç\u{2001}Pattern\u{2001}‚Äî [default: .git]\n  -O, --Omit <OMIT>        üö´\u{2001}Omit\u{2001}‚Äî [default: Documentation]\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\n\n#### --Exclude or -E:\n\nExclude certain files or directories (defailt is `node_modules`).\n\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n\n#### --Parallel or -P:\n\nRun processing in parallel (default is `sequential`):\n\n#### --Pattern:\n\nSpecify a custom pattern for matching (defailt is `.git`).\n\n#### --Root or -R:\n\nSet the current working directory to a different folder (default is `.`):\n\nFor [Pieces OS] integration, refer to the [Pieces OS] documentation for specific\nflags and configuration options. [Pieces OS]\n\n## Examples\n\nAnalyze the current directory:\n\n```sh\nSummary -R D:\\Developer .git git fetch upstream\nSummary\n```\n\n#### --Parallel or -P:\n\nSummary commands in `parallel` (default is `sequential`):\nAnalyze a specific directory in parallel:\n\n```sh\nSummary -P -R D:\\Developer .git git fetch upstream\nSummary -P -R D:\\Developer\n```\n\n#### --Exclude:\nExclude additional directories:\n\nExclude certain files or directories (defailt is\n`node_modules target dist vendor`)\n```sh\nSummary -E \"node_modules target dist vendor\"\n```\n\n#### --Pattern:\nOmit specific file patterns:\n\nSpecify a custom pattern for matching (defailt is `.git`)\n```sh\nSummary -O \"\\.md$\" -O \"\\.txt$\"\n```\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n\n-   `clap` - Parses command-line arguments\n-   `rayon` - Enables parallel processing\n-   `tokio` - Provides an asynchronous runtime\n-   `walkdir` - Facilitates efficient filesystem traversal\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\n-   `tokio` - For asynchronous runtime.\n-   `walkdir` - For efficient filesystem traversal.\n\n[Pieces OS] For extended functionality and system integration.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n[Pieces OS]: HTTPS://Pieces.App\n\n## Changelog\n\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex e69de29..4cfbb9f 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -0,0 +1,76 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n///\n/// # Example\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n\t\t.author(\"üñã\u{fe0f}\u{2001}Source\u{2001}‚Äî\u{2001}üëêüèª\u{2001}Open\u{2001}‚Äî <Source/Open@PlayForm.Cloud>\")\n\t\t.about(\"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\")\n\t\t.arg(\n\t\t\tArg::new(\"Exclude\")\n\t\t\t\t.short('E')\n\t\t\t\t.long(\"Exclude\")\n\t\t\t\t.display_order(4)\n\t\t\t\t.value_name(\"EXCLUDE\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Exclude\u{2001}‚Äî\")\n\t\t\t\t.default_value(\"node_modules\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Omit\")\n\t\t\t\t.short('O')\n\t\t\t\t.long(\"Omit\")\n\t\t\t\t.display_order(6)\n\t\t\t\t.value_name(\"OMIT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\n\t\t\t\t.short('P')\n\t\t\t\t.long(\"Parallel\")\n\t\t\t\t.action(SetTrue)\n\t\t\t\t.display_order(2)\n\t\t\t\t.value_name(\"PARALLEL\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"‚è©\u{2001}Parallel\u{2001}‚Äî\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Pattern\")\n\t\t\t\t.long(\"Pattern\")\n\t\t\t\t.display_order(5)\n\t\t\t\t.value_name(\"PATTERN\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üîç\u{2001}Pattern\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".git\"),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Root\")\n\t\t\t\t.short('R')\n\t\t\t\t.long(\"Root\")\n\t\t\t\t.display_order(3)\n\t\t\t\t.value_name(\"ROOT\")\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üìÇ\u{2001}Root\u{2001}‚Äî\")\n\t\t\t\t.default_value(\".\"),\n\t\t)\n\t\t.get_matches()\n}\n\nuse clap::{Arg, ArgAction::SetTrue, ArgMatches, Command};\n\npub mod Entry;\npub mod Parallel;\npub mod Sequential;\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..64351c7\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -0,0 +1,51 @@\n/// Walks through a directory and filters files based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\n\t\t.into_iter()\n\t\t.filter_map(|Entry| {\n\t\t\tlet Path = Entry.expect(\"Cannot Entry.\").path().display().to_string();\n\n\t\t\t// TODO: Separate this into Entry/Exclude.rs\n\t\t\tif !Exclude\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|Exclude| *Pattern != *Exclude)\n\t\t\t\t.any(|Exclude| Path.contains(&Exclude))\n\t\t\t{\n\t\t\t\tSome(Path.split(*Separator).map(|Entry| Entry.to_string()).collect())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.collect::<Vec<_>>()\n}\n\nuse crate::Struct::Binary::Command::{Entry::Type as Return, Option::Struct as Option};\n\nuse walkdir::WalkDir;\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nnew file mode 100644\nindex 0000000..22654c0\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -0,0 +1,55 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.collect::<Vec<String>>(),\n\t)\n\t.map(|Entry| {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\tErr(_Error) => Err(format!(\"Error generating summary for {}: {}\", Entry, _Error)),\n\t\t\t}\n\t\t}\n\t})\n\t.buffer_unordered(num_cpus::get())\n\t.collect::<Vec<_>>()\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nnew file mode 100644\nindex 0000000..7ffeb0f\n--- /dev/null\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -0,0 +1,52 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\n\t\t\t.into_iter()\n\t\t\t.filter_map(|Entry| {\n\t\t\t\tEntry\n\t\t\t\t\t.last()\n\t\t\t\t\t.filter(|Last| *Last == &Pattern)\n\t\t\t\t\t.map(|_| Entry[0..Entry.len() - 1].join(&Separator.to_string()))\n\t\t\t})\n\t\t\t.map(|Entry| {\n\t\t\t\tlet Omit = Omit.clone();\n\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n\t\t\t\t\t\tOk(Summary) => Ok(Summary),\n\t\t\t\t\t\tErr(_Error) => {\n\t\t\t\t\t\t\tErr(format!(\"Error generating summary for {}: {}\", Entry, _Error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/mod.rs b/Source/Fn/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Fn/mod.rs\n+++ b/Source/Fn/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nnew file mode 100644\nindex 0000000..ae3e650\n--- /dev/null\n+++ b/Source/Fn/Summary.rs\n@@ -0,0 +1,49 @@\n/// Generates a summary based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n\n\tOk(())\n}\n\nuse git2::Repository;\n\npub mod Difference;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..cc25057\n--- /dev/null\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -0,0 +1,122 @@\n/// Calculates the difference between two summaries.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n\tOptions.minimal(true);\n\tOptions.force_text(true);\n\tOptions.ignore_blank_lines(true);\n\tOptions.ignore_case(true);\n\tOptions.ignore_filemode(true);\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n\t\t\tSome(&Repository.revparse_single(Start)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&Repository.revparse_single(End)?.peel_to_commit()?.tree()?),\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n\t\t})?;\n\n\tOk(Difference)\n}\n\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 62cfaff..6864249 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,10 +1,14 @@\n#![allow(non_snake_case)]\n\nmod Fn;\nmod Struct;\n\n/// The main entry point for the Summary application.\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\n\t(Struct::Binary::Command::Struct::Fn().Fn)().await\n}\n\npub mod Fn;\npub mod Struct;\ndiff --git a/Source/main.rs b/Source/main.rs\ndeleted file mode 100644\nindex 3f3ccf9..0000000\n--- a/Source/main.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\nuse git2::{DiffOptions, Repository};\nuse std::{\n\tfs::{self, File},\n\tio::Write,\n\tpath::Path,\n};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n\t// Clone the repository (if you haven't already)\n\tlet repo_url = \"<repository_url>\";\n\tlet repo_path = \"<repository_name>\";\n\tif !Path::new(repo_path).exists() {\n\t\tRepository::clone(repo_url, repo_path)?;\n\t}\n\tlet repo = Repository::open(repo_path)?;\n\n\t// List all tags\n\tlet tags = repo.tag_names(None)?;\n\tlet mut previous_tag = None;\n\n\t// Create the Summary directory if it doesn't exist\n\tlet summary_dir = \"Summary\";\n\tfs::create_dir_all(summary_dir)?;\n\n\tfor i in 0..tags.len() {\n\t\tif let Some(tag) = tags.get(i) {\n\t\t\tif let Some(prev_tag) = previous_tag {\n\t\t\t\t// Generate diff between previous_tag and current tag\n\t\t\t\tlet diff = Diff(&repo, prev_tag, tag)?;\n\t\t\t\tlet diff_file_path = format!(\"{}/diff_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut diff_file = File::create(&diff_file_path)?;\n\t\t\t\tdiff_file.write_all(diff.as_bytes())?;\n\n\t\t\t\t// Generate release message\n\t\t\t\tlet release_message = Release(&diff);\n\t\t\t\tlet release_file_path = format!(\"{}/release_{}_{}.txt\", summary_dir, prev_tag, tag);\n\t\t\t\tlet mut release_file = File::create(&release_file_path)?;\n\t\t\t\trelease_file.write_all(release_message.as_bytes())?;\n\t\t\t}\n\t\t\tprevious_tag = Some(tag);\n\t\t}\n\t}\n\n\tOk(())\n}\n\nfn Diff(repo: &Repository, old_tag: &str, new_tag: &str) -> Result<String, git2::Error> {\n\tlet Old = repo.revparse_single(old_tag)?.peel_to_commit()?;\n\tlet New = repo.revparse_single(new_tag)?.peel_to_commit()?;\n\n\tlet mut Options = DiffOptions::new();\n\tlet diff = repo.diff_tree_to_tree(\n\t\tSome(&Old.tree()?),\n\t\tSome(&New.tree()?),\n\t\tSome(&mut Options),\n\t)?;\n\n\tlet mut diff_str = String::new();\n\tdiff.print(git2::DiffFormat::Patch, |_, _, line| {\n\t\tdiff_str.push_str(std::str::from_utf8(line.content()).unwrap());\n\t\ttrue\n\t})?;\n\n\tOk(diff_str)\n}\n\nfn Release(diff: &str) -> String {\n\t// This is a simple example. You can enhance this function to generate more detailed messages.\n\tlet mut release_message = String::new();\n\trelease_message.push_str(\"Release Notes:\\n\");\n\tfor line in diff.lines() {\n\t\tif line.starts_with(\"+\") && !line.starts_with(\"+++\") {\n\t\t\trelease_message.push_str(&format!(\"Added: {}\\n\", &line[1..]));\n\t\t} else if line.starts_with(\"-\") && !line.starts_with(\"---\") {\n\t\t\trelease_message.push_str(&format!(\"Removed: {}\\n\", &line[1..]));\n\t\t}\n\t}\n\trelease_message\n}\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nnew file mode 100644\nindex 0000000..4a356ae\n--- /dev/null\n+++ b/Source/Struct/Binary/Command.rs\n@@ -0,0 +1,37 @@\n/// Represents the main command structure for the Summary application.\npub struct Struct {\n\t/// The path separator character.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n\t\t\tFn: Box::new(|| {\n\t\t\t\tBox::pin(async move {\n\t\t\t\t\tlet Option = Entry::Struct::Fn(&Option::Struct::Fn(Struct::Fn()));\n\n\t\t\t\t\tmatch Option.Parallel {\n\t\t\t\t\t\ttrue => {\n\t\t\t\t\t\t\tParallel::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfalse => {\n\t\t\t\t\t\t\tSequential::Fn(Option).await;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t}),\n\t\t}\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nnew file mode 100644\nindex 0000000..45d3e41\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -0,0 +1,36 @@\n/// Represents the entry options for processing in the Summary command.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n\t\t\tOmit: Option.Omit.clone(),\n\t\t\tParallel: Option.Parallel,\n\t\t\tPattern: Option.Pattern.clone(),\n\t\t\tSeparator: Option.Separator,\n\t\t}\n\t}\n}\n\nuse crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nnew file mode 100644\nindex 0000000..8d32f31\n--- /dev/null\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -0,0 +1,51 @@\n/// Represents the configuration options for the Summary command.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\n\t\t\t\t.get_one::<String>(\"Exclude\")\n\t\t\t\t.expect(\"Cannot Exclude.\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.map(|Exclude| Exclude.to_string())\n\t\t\t\t.collect::<Vec<_>>(),\n\t\t\tParallel: Command().get_flag(\"Parallel\"),\n\t\t\tPattern: Command().get_one::<String>(\"Pattern\").expect(\"Cannot Pattern.\").to_owned(),\n\t\t\tRoot: Command().get_one::<String>(\"Root\").expect(\"Cannot Root.\").to_owned(),\n\t\t\tSeparator,\n\t\t\tOmit: Command()\n\t\t\t\t.get_many::<String>(\"Omit\")\n\t\t\t\t.expect(\"Cannot Omit.\")\n\t\t\t\t.map(|Omit| Omit.to_string())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nuse crate::{Fn::Binary::Command::Fn as Command, Struct::Binary::Command::Struct as Option};\n\npub type Command = Vec<String>;\npub type Parallel = bool;\npub type Pattern = String;\npub type Separator = char;\npub type Omit = Vec<String>;\ndiff --git a/Source/Struct/Binary/mod.rs b/Source/Struct/Binary/mod.rs\nnew file mode 100644\nindex 0000000..9da7843\n--- /dev/null\n+++ b/Source/Struct/Binary/mod.rs\n@@ -0,0 +1 @@\npub mod Command;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nnew file mode 100644\nindex 0000000..4ca5f2b\n--- /dev/null\n+++ b/Source/Struct/mod.rs\n@@ -0,0 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n\nüó£\u{fe0f} Summary from latest tag: Summary/v0.0.5 to last commit:\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 3615257..c907ec5 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,7 +18,7 @@ regex = \"1.10.5\"\n\n[build-dependencies]\nserde = { version = \"1.0.204\", features = [\"derive\"] }\ntoml = \"0.8.16\"\ntoml = \"0.8.17\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.5\"\nversion = \"0.0.7\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 4449a1b..d388d49 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,11 +1,18 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient `Git`\n[Summary] is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n```sh\nSummary -P -O Target -O target -O Summary.md -O CHANGELOG.md > Summary.md\n```\n\n[Summary] will now generate the following [Summary.md](./Summary.md) for all the\ncommits and tags between the first and the latest commit.\n\n## Features\n\n-   Customizable file pattern matching.\n@@ -18,14 +25,14 @@ processing capabilities, along with flexible file filtering options.\n\n## [Pieces OS] Integration\n\nThe `Summary` CLI supports [Pieces OS], allowing it to:\nThe [Summary] CLI supports [Pieces OS], allowing it to:\n\n-   Generate comprehensive diff logs and release notes automatically.\n-   Provide AI-driven code analysis and insights.\n-   Offer improved context-aware processing of repository changes.\n-   Seamlessly interact with other [Pieces OS]-compatible development tools.\n\nBy leveraging [Pieces OS], `Summary` can tap into a broader ecosystem of development\nBy leveraging [Pieces OS], [Summary] can tap into a broader ecosystem of development\ntools and services, significantly expanding its capabilities beyond basic file processing.\n\n## Installation\n@@ -58,7 +65,7 @@ repository.\n\n## Options\n\nThe `Summary` tool can be used with various options:\nThe [Summary] tool can be used with various options:\n\n#### --Exclude or -E:\n\n@@ -67,7 +74,7 @@ Exclude certain files or directories (defailt is `node_modules`).\n#### --Omit or -O:\n\nSpecify regex patterns to omit files from processing (default is\n\"Documentation\").\n`Documentation`).\n\n#### --Parallel or -P:\n\n@@ -112,7 +119,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n## Dependencies\n\n`Summary` relies on several Rust crates to provide its functionality:\n[Summary] relies on several Rust crates to provide its functionality:\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\ndiff --git a/Source/Fn/Binary/Command.rs b/Source/Fn/Binary/Command.rs\nindex 4cfbb9f..e355a33 100644\n--- a/Source/Fn/Binary/Command.rs\n+++ b/Source/Fn/Binary/Command.rs\n@@ -1,16 +1,13 @@\n/// Defines and configures command-line arguments for the \"Summary\" command.\n///\n/// # Returns\n//! This module defines the command-line interface for the Summary application.\n\n/// Configures and returns the command-line argument matches for the Summary application.\n///\n/// * `ArgMatches` - The parsed command-line arguments.\n/// This function sets up the command-line interface using the clap crate, defining\n/// various arguments and their properties.\n///\n/// # Example\n/// # Returns\n///\n/// ```\n/// let matches = Fn();\n/// let parallel = matches.get_flag(\"Parallel\");\n/// let root = matches.get_one::<String>(\"Root\").unwrap();\n/// ```\n/// Returns an `ArgMatches` struct containing the parsed command-line arguments.\npub fn Fn() -> ArgMatches {\n\tCommand::new(\"Summary\")\n\t\t.version(env!(\"CARGO_PKG_VERSION\"))\n@@ -35,7 +32,7 @@ pub fn Fn() -> ArgMatches {\n\t\t\t\t.required(false)\n\t\t\t\t.help(\"üö´\u{2001}Omit\u{2001}‚Äî\")\n\t\t\t\t.action(clap::ArgAction::Append)\n\t\t\t\t.default_value(\"Documentation\"),\n\t\t\t\t.default_values([\"Target\", \"Documentation\", r\"Summary\\.md$\"]),\n\t\t)\n\t\t.arg(\n\t\t\tArg::new(\"Parallel\")\ndiff --git a/Source/Fn/Binary/Command/Entry.rs b/Source/Fn/Binary/Command/Entry.rs\nindex 64351c7..387c0e4 100644\n--- a/Source/Fn/Binary/Command/Entry.rs\n+++ b/Source/Fn/Binary/Command/Entry.rs\n@@ -1,29 +1,14 @@\n/// Walks through a directory and filters files based on specified criteria.\n//! This module provides functionality for processing binary command entries.\n\n/// Processes entries based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Exclude`: Vec<String> - List of patterns to exclude\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Root`: String - The root directory to start the walk from\n///   * `Separator`: char - The path separator character\n/// * `Option` - A reference to an Option struct containing processing parameters.\n///\n/// # Returns\n///\n/// * `Return` - A vector of vectors of strings, where each inner vector represents a file path\n///   split into its components.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     Exclude: vec![\"node_modules\".to_string()],\n///     Pattern: \".git\".to_string(),\n///     Root: \".\".to_string(),\n///     Separator: std::path::MAIN_SEPARATOR,\n/// };\n/// let result = Fn(&option);\n/// ```\n/// Returns a vector of processed entries.\npub fn Fn(Option { Exclude, Pattern, Root, Separator, .. }: &Option) -> Return {\n\tWalkDir::new(Root)\n\t\t.follow_links(false)\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 22654c0..75ef690 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -1,22 +1,18 @@\n/// Processes entries in parallel, filtering and executing commands based on specified criteria.\n//! This module contains functions for parallel command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously in parallel based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Separator`: char - The path separator character\n///   * `Pattern`: String - The pattern to match for inclusion\n/// * `Option` - A struct containing various options for execution, including:\n///   - `Entry`: A collection of entries to process\n///   - `Separator`: A separator used for joining entry parts\n///   - `Pattern`: A pattern to match against the last element of each entry\n///   - `Omit`: A collection of items to omit from processing\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Separator: '/',\n///     Pattern: \"file.txt\".to_string(),\n/// };\n/// Fn(option).await;\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tfutures::stream::iter(\n\t\tEntry\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex 7ffeb0f..a84435b 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -1,22 +1,14 @@\n/// Processes entries sequentially, filtering and executing commands based on specified criteria.\n//! This module contains functions for sequential command execution in a binary context.\n\n/// Executes a sequence of operations asynchronously based on the provided options.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the following fields:\n///   * `Entry`: Vec<Vec<String>> - List of entries to process\n///   * `Pattern`: String - The pattern to match for inclusion\n///   * `Separator`: char - The path separator character\n/// * `Option` - A struct containing various options for execution.\n///\n/// # Example\n/// # Async\n///\n/// ```\n/// let option = Option {\n///     Entry: vec![vec![\"path\".to_string(), \"to\".to_string(), \"file.txt\".to_string()]],\n///     Pattern: \"file.txt\".to_string(),\n///     Separator: '/',\n/// };\n/// Fn(option);\n/// ```\n/// This function is asynchronous and returns a future.\npub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\tfutures::future::join_all(\n\t\tEntry\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex ae3e650..f199ca3 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -1,21 +1,20 @@\n/// Generates a summary based on the provided options.\n//! This module provides functionality for generating summaries of git repositories.\n\n/// Generates a summary for a given git repository entry.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for generating the summary.\n/// * `Entry` - A string representing the repository path.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// * `Return` - The generated summary.\n/// Returns a Result containing () if successful, or a boxed dynamic error if an error occurs.\n///\n/// # Example\n/// # Errors\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for summary generation\n/// };\n/// let summary = Fn(&option);\n/// ```\n/// This function will return an error if the repository cannot be opened or if there are issues\n/// generating the summary.\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n@@ -26,17 +25,52 @@ pub async fn Fn(\n\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\tlet Head = Repository.head()?;\n\n\t\t\tlet First = Repository.find_commit(First::Fn(&Repository)?)?.id().to_string();\n\n\t\t\tlet Last = Head.peel_to_commit()?.id().to_string();\n\n\t\t\tif Tag.is_empty() {\n\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to last commit:\");\n\n\t\t\t\tprintln!(\n\t\t\t\t\t\"{}\",\n\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, &Last, Option,)?\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor Window in Tag.windows(2) {\n\t\t\t\t\tlet Start = Window[0];\n\t\t\t\t\tlet End = Window[1];\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from tag: {} to tag: {}:\", Start, End);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Start, End, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif let Some(Latest) = Tag.last() {\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from first commit to latest tag: {}:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, &First, Latest, Option)?\n\t\t\t\t\t);\n\n\t\t\t\t\tprintln!(\"üó£\u{fe0f} Summary from latest tag: {} to last commit:\", Latest);\n\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Latest, &Last, Option)?\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tErr(_Error) => {\n\t\t\tprintln!(\"Failed to open repository: {}\", _Error);\n\t\t\tprintln!(\"Cannot Repository: {}\", _Error);\n\n\t\t\treturn Err(_Error.into());\n\t\t}\n\t}\n@@ -47,3 +81,4 @@ pub async fn Fn(\nuse git2::Repository;\n\npub mod Difference;\npub mod First;\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex cc25057..544095b 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -1,21 +1,18 @@\n/// Calculates the difference between two summaries.\n//! This module provides functionality for generating difference summaries between git commits.\n\n/// Generates a difference summary between two git commits.\n///\n/// # Arguments\n///\n/// * `Option` - A struct containing the necessary information for calculating the difference.\n/// * `Repository` - A reference to the git Repository.\n/// * `Start` - The starting commit or reference.\n/// * `End` - The ending commit or reference.\n/// * `Option` - A reference to a struct containing difference options.\n///\n/// # Returns\n///\n/// * `Return` - The calculated difference between the summaries.\n///\n/// # Example\n///\n/// ```\n/// let option = Option {\n///     // Fields needed for difference calculation\n/// };\n/// let difference = Fn(&option);\n/// ```\n/// Returns a Result containing a String with the difference summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n@@ -23,56 +20,59 @@ pub fn Fn(\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dll\\.lib$\",\n\t\tr\"\\.dll\\.exp$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.pdb$\",\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.zip$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\ndiff --git a/Source/Fn/Summary/First.rs b/Source/Fn/Summary/First.rs\nnew file mode 100644\nindex 0000000..a0c3df6\n--- /dev/null\n+++ b/Source/Fn/Summary/First.rs\n@@ -0,0 +1,26 @@\n//! This module provides functionality for generating summaries of the first commit in a git repository.\n\n/// Generates a summary of the first commit in a git repository.\n///\n/// # Arguments\n///\n/// * `Repository` - A reference to the git Repository.\n/// * `Option` - A reference to a struct containing summary options.\n///\n/// # Returns\n///\n/// Returns a Result containing a String with the summary if successful,\n/// or a boxed dynamic error if an error occurs.\npub fn Fn(Repository: &Repository) -> Result<Oid, git2::Error> {\n\tlet mut Walk = Repository.revwalk()?;\n\tWalk.push_head()?;\n\tWalk.set_sorting(Sort::TOPOLOGICAL | Sort::REVERSE)?;\n\n\tmatch Walk.next() {\n\t\tSome(Ok(Identifier)) => Ok(Identifier),\n\t\tSome(Err(_Error)) => Err(_Error),\n\t\tNone => Err(git2::Error::from_str(\"Cannot git2.\")),\n\t}\n}\n\nuse git2::{Oid, Repository, Sort};\ndiff --git a/Source/Library.rs b/Source/Library.rs\nindex 6864249..7b297ec 100644\n--- a/Source/Library.rs\n+++ b/Source/Library.rs\n@@ -1,9 +1,13 @@\n//! The main entry point for the Summary application.\n\n#![allow(non_snake_case)]\n\n/// The main entry point for the Summary application.\n/// The main function that initializes and runs the `Summary` application.\n///\n/// # Errors\n///\n/// This function initializes the command structure and executes the appropriate\n/// command based on the provided command-line arguments.\n/// This function will return an error if there are issues parsing arguments\n/// or executing the requested commands.\n#[allow(dead_code)]\n#[tokio::main]\nasync fn main() {\ndiff --git a/Source/Struct/Binary/Command.rs b/Source/Struct/Binary/Command.rs\nindex 4a356ae..7473837 100644\n--- a/Source/Struct/Binary/Command.rs\n+++ b/Source/Struct/Binary/Command.rs\n@@ -1,12 +1,23 @@\n/// Represents the main command structure for the Summary application.\n//! This module defines the main command structure and its implementation for the binary command execution.\n\n/// Represents the main command structure for binary command execution.\npub struct Struct {\n\t/// The path separator character.\n\t/// The separator used for file paths.\n\tpub Separator: Option::Separator,\n\t/// A boxed function that returns a pinned future.\n\n\t/// A boxed function that returns a pinned future representing the command execution.\n\tpub Fn: Box<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + 'static>,\n}\n\nimpl Struct {\n\t/// Creates a new instance of the Struct.\n\t///\n\t/// This function initializes the Struct with the system's main separator\n\t/// and a boxed async function that handles command execution.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn() -> Self {\n\t\tSelf {\n\t\t\tSeparator: std::path::MAIN_SEPARATOR,\n@@ -28,10 +39,10 @@ impl Struct {\n\t}\n}\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\n\nuse futures::Future;\nuse std::pin::Pin;\n\npub mod Entry;\npub mod Option;\n\nuse crate::Fn::Binary::Command::{Parallel, Sequential};\ndiff --git a/Source/Struct/Binary/Command/Entry.rs b/Source/Struct/Binary/Command/Entry.rs\nindex 45d3e41..ee24305 100644\n--- a/Source/Struct/Binary/Command/Entry.rs\n+++ b/Source/Struct/Binary/Command/Entry.rs\n@@ -1,22 +1,28 @@\n/// Represents the entry options for processing in the Summary command.\n//! This module defines structures and functions related to binary command entries.\n\n/// Represents the structure for binary command entries.\npub struct Struct {\n\t/// The path.\n\tpub Entry: Type,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Omit,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - A reference to an Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option: &Option) -> Self {\n\t\tSelf {\n\t\t\tEntry: crate::Fn::Binary::Command::Entry::Fn(Option),\n@@ -32,5 +38,4 @@ use crate::Struct::Binary::Command::Option::{\n\tOmit, Parallel, Pattern, Separator, Struct as Option,\n};\n\n/// Defines a type alias for a vector of vectors of strings.\npub type Type = Vec<Vec<String>>;\ndiff --git a/Source/Struct/Binary/Command/Option.rs b/Source/Struct/Binary/Command/Option.rs\nindex 8d32f31..3f069ff 100644\n--- a/Source/Struct/Binary/Command/Option.rs\n+++ b/Source/Struct/Binary/Command/Option.rs\n@@ -1,26 +1,30 @@\n/// Represents the configuration options for the Summary command.\n//! This module defines structures and functions related to binary command options.\n\n/// Represents the structure for binary command options.\npub struct Struct {\n\t/// List of patterns to exclude from processing.\n\tpub Exclude: Vec<String>,\n\n\t/// List of items to omit from processing.\n\tpub Omit: Vec<String>,\n\n\t/// Flag indicating whether to use parallel processing.\n\tpub Parallel: Parallel,\n\n\t/// The pattern to match for inclusion in processing.\n\tpub Pattern: Pattern,\n\n\t/// The root directory to start processing from.\n\tpub Root: String,\n\n\t/// The path separator character.\n\tpub Separator: Separator,\n}\n\nimpl Struct {\n\t/// Creates a new Struct instance from the provided Option.\n\t/// Creates a new Struct instance from the given options.\n\t///\n\t/// # Arguments\n\t///\n\t/// * `Option` - An Option struct containing initialization parameters.\n\t///\n\t/// # Returns\n\t///\n\t/// Returns a new instance of Struct.\n\tpub fn Fn(Option { Separator, .. }: Option) -> Self {\n\t\tSelf {\n\t\t\tExclude: Command()\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nindex 7583a0a..bb7ec8e 100644\n--- a/Source/Struct/Summary/Difference.rs\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -1,3 +1,6 @@\n//! This module defines structures related to git diff summary options.\n\n/// Represents the options for generating a git diff summary.\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\n\n\n", "üó£\u{fe0f} Summary from tag: Summary/v0.0.6 to tag: Summary/v0.0.7:"), 15721250723289482149: ("diff --git a/Cargo.toml b/Cargo.toml\nindex 3d3159a..3615257 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -35,5 +35,5 @@ description = \"üó£\u{fe0f}\u{2001}Summary\u{2001}‚Äî\"\nlicense = \"MIT\"\nname = \"psummary\"\nrepository = \"https://github.com/PlayForm/Summary.git\"\nversion = \"0.0.4\"\nversion = \"0.0.5\"\nedition = \"2021\"\ndiff --git a/README.md b/README.md\nindex 49bf9ea..4449a1b 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,20 +1,20 @@\n# üó£\u{fe0f}\u{2001}[Summary]\u{2001}‚Äî\n\n`Summary` is a powerful command-line tool designed for efficient Git repository\nanalysis and summarization. It offers both sequential and parallel processing\ncapabilities, along with flexible file filtering options.\n`Summary` is a powerful command-line tool designed for efficient `Git`\nrepository analysis and summarization. It offers both sequential and parallel\nprocessing capabilities, along with flexible file filtering options.\n\n[Summary]: HTTPS://crates.io/crates/psummary\n\n## Features\n\n-   Customizable file pattern matching\n-   Diff generation between `Git` tags\n-   Directory traversal and file filtering\n-   Exclusion of specified files or directories\n-   `Git` repository analysis\n-   Integration with [Pieces OS] for enhanced functionality\n-   Parallel and sequential processing modes\n-   Customizable file pattern matching.\n-   Diff generation between `Git` tags.\n-   Directory traversal and file filtering.\n-   Exclusion of specified files or directories.\n-   `Git` repository analysis.\n-   Integration with [Pieces OS] for enhanced functionality.\n-   Parallel and sequential processing modes.\n\n## [Pieces OS] Integration\n\n@@ -53,7 +53,7 @@ Options:\n  -V, --version            Print version\n```\n\nThis command will generate summaries for all the Git tags inside the specified\nThis command will generate summaries for all the `Git` tags inside the specified\nrepository.\n\n## Options\n@@ -116,7 +116,7 @@ Summary -O \"\\.md$\" -O \"\\.txt$\"\n\n-   `clap` - For parsing command-line arguments.\n-   `futures` - For asynchronous programming abstractions.\n-   `git2` - For Git repository operations.\n-   `git2` - For `Git` repository operations.\n-   `num_cpus` - For determining the number of CPUs for parallel processing.\n-   `rayon` - For parallel processing.\n-   `regex` - For pattern matching and text manipulation.\ndiff --git a/Source/Fn/Binary/Command/Parallel.rs b/Source/Fn/Binary/Command/Parallel.rs\nindex 463f890..22654c0 100644\n--- a/Source/Fn/Binary/Command/Parallel.rs\n+++ b/Source/Fn/Binary/Command/Parallel.rs\n@@ -18,7 +18,7 @@\n/// Fn(option).await;\n/// ```\npub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\tstream::iter(\n\tfutures::stream::iter(\n\t\tEntry\n\t\t\t.into_par_iter()\n\t\t\t.filter_map(|Entry| {\n@@ -33,7 +33,10 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t\tlet Omit = Omit.clone();\n\n\t\tasync move {\n\t\t\tmatch crate::Fn::Summary::Fn(&Entry, &crate::Fn::Summary::Difference::Option { Omit })\n\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t&Entry,\n\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(Summary) => Ok(Summary),\n@@ -46,6 +49,7 @@ pub async fn Fn(Option { Entry, Separator, Pattern, Omit, .. }: Option) {\n\t.await;\n}\n\nuse futures::stream::StreamExt;\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\nuse futures::stream::{self, StreamExt};\nuse rayon::prelude::*;\ndiff --git a/Source/Fn/Binary/Command/Sequential.rs b/Source/Fn/Binary/Command/Sequential.rs\nindex c19801b..7ffeb0f 100644\n--- a/Source/Fn/Binary/Command/Sequential.rs\n+++ b/Source/Fn/Binary/Command/Sequential.rs\n@@ -33,7 +33,7 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\tasync move {\n\t\t\t\t\tmatch crate::Fn::Summary::Fn(\n\t\t\t\t\t\t&Entry,\n\t\t\t\t\t\t&crate::Fn::Summary::Difference::Option { Omit },\n\t\t\t\t\t\t&crate::Struct::Summary::Difference::Struct { Omit },\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t{\n@@ -45,7 +45,8 @@ pub async fn Fn(Option { Entry, Pattern, Separator, Omit, .. }: Option) {\n\t\t\t\t}\n\t\t\t})\n\t\t\t.collect::<Vec<_>>(),\n\t).await;\n\t)\n\t.await;\n}\n\nuse crate::Struct::Binary::Command::Entry::Struct as Option;\ndiff --git a/Source/Fn/Summary.rs b/Source/Fn/Summary.rs\nindex f6825a8..ae3e650 100644\n--- a/Source/Fn/Summary.rs\n+++ b/Source/Fn/Summary.rs\n@@ -18,16 +18,16 @@\n/// ```\npub async fn Fn(\n\tEntry: &str,\n\tOption: &crate::Fn::Summary::Difference::Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<(), Box<dyn std::error::Error>> {\n\tmatch Repository::open(Entry) {\n\t\tOk(Repository) => {\n\t\t\tlet Tag = Repository.tag_names(None)?;\n\t\t\tlet Name = Repository.tag_names(None)?;\n\n\t\t\tlet Tags: Vec<_> = Tag.iter().filter_map(|Tag| Tag).collect();\n\t\t\tlet Tag: Vec<_> = Name.iter().filter_map(|Tag| Tag).collect();\n\n\t\t\tfor (Index, &Current) in Tags.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tags.iter().enumerate().skip(Index + 1) {\n\t\t\tfor (Index, &Current) in Tag.iter().enumerate() {\n\t\t\t\tfor (_, &Next) in Tag.iter().enumerate().skip(Index + 1) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"{}\",\n\t\t\t\t\t\tcrate::Fn::Summary::Difference::Fn(&Repository, Current, Next, Option)?\ndiff --git a/Source/Fn/Summary/Difference.rs b/Source/Fn/Summary/Difference.rs\nindex d96794d..cc25057 100644\n--- a/Source/Fn/Summary/Difference.rs\n+++ b/Source/Fn/Summary/Difference.rs\n@@ -20,9 +20,65 @@ pub fn Fn(\n\tRepository: &git2::Repository,\n\tStart: &str,\n\tEnd: &str,\n\tOption: &Option,\n\tOption: &crate::Struct::Summary::Difference::Struct,\n) -> Result<String, git2::Error> {\n\tlet mut Difference = String::new();\n\tlet mut Omit = vec![\n\t\tr\"\\.pdf$\",\n\t\tr\"\\.exe$\",\n\t\tr\"\\.dll$\",\n\t\tr\"\\.so$\",\n\t\tr\"\\.dylib$\",\n\t\tr\"\\.zip$\",\n\t\tr\"\\.tar$\",\n\t\tr\"\\.gz$\",\n\t\tr\"\\.7z$\",\n\t\tr\"\\.rar$\",\n\t\tr\"\\.jpg$\",\n\t\tr\"\\.jpeg$\",\n\t\tr\"\\.png$\",\n\t\tr\"\\.gif$\",\n\t\tr\"\\.bmp$\",\n\t\tr\"\\.tiff$\",\n\t\tr\"\\.ico$\",\n\t\tr\"\\.svg$\",\n\t\tr\"\\.webp$\",\n\t\tr\"\\.heic$\",\n\t\tr\"\\.mp3$\",\n\t\tr\"\\.wav$\",\n\t\tr\"\\.ogg$\",\n\t\tr\"\\.flac$\",\n\t\tr\"\\.m4a$\",\n\t\tr\"\\.mp4$\",\n\t\tr\"\\.avi$\",\n\t\tr\"\\.mov$\",\n\t\tr\"\\.mkv$\",\n\t\tr\"\\.wmv$\",\n\t\tr\"\\.doc$\",\n\t\tr\"\\.docx$\",\n\t\tr\"\\.xls$\",\n\t\tr\"\\.xlsx$\",\n\t\tr\"\\.ppt$\",\n\t\tr\"\\.pptx$\",\n\t\tr\"\\.db$\",\n\t\tr\"\\.sqlite$\",\n\t\tr\"\\.mdb$\",\n\t\tr\"\\.accdb$\",\n\t\tr\"\\.class$\",\n\t\tr\"\\.pyc$\",\n\t\tr\"\\.pyo$\",\n\t\tr\"\\.o$\",\n\t\tr\"\\.obj$\",\n\t\tr\"\\.bin$\",\n\t\tr\"\\.dat$\",\n\t\tr\"\\.bak$\",\n\t\tr\"\\.iso$\",\n\t\tr\"\\.img$\",\n\t];\n\n\tOmit.extend(Option.Omit.iter().map(|Omit| Omit.as_str()));\n\n\tlet Regex = Omit.into_par_iter().filter_map(|Omit| Regex::new(Omit).ok()).collect::<Vec<_>>();\n\n\tlet mut Options = git2::DiffOptions::new();\n\n\tOptions.indent_heuristic(true);\n@@ -34,6 +90,10 @@ pub fn Fn(\n\tOptions.ignore_whitespace(true);\n\tOptions.ignore_whitespace_change(true);\n\tOptions.ignore_whitespace_eol(true);\n\tOptions.show_binary(false);\n\tOptions.force_binary(false);\n\n\tlet mut Difference = String::new();\n\n\tRepository\n\t\t.diff_tree_to_tree(\n@@ -42,17 +102,14 @@ pub fn Fn(\n\t\t\tSome(&mut Options),\n\t\t)?\n\t\t.print(git2::DiffFormat::Patch, |Delta, _, Line| {\n\t\t\tif !Option\n\t\t\t\t.Omit\n\t\t\t\t.iter()\n\t\t\t\t.map(|Omit: &String| regex::Regex::new(Omit).expect(\"Cannot Regex.\"))\n\t\t\t\t.collect::<Vec<_>>()\n\t\t\t\t.iter()\n\t\t\t\t.any(|Omit| {\n\t\t\tif !Regex.iter().any(|Omit| {\n\t\t\t\tOmit.is_match(&Delta.old_file().path().unwrap().display().to_string())\n\t\t\t\t\t|| Omit.is_match(&Delta.new_file().path().unwrap().display().to_string())\n\t\t\t}) {\n\t\t\t\tDifference.push_str(std::str::from_utf8(Line.content()).unwrap());\n\t\t\t\tmatch std::str::from_utf8(Line.content()) {\n\t\t\t\t\tOk(Line) => Difference.push_str(Line),\n\t\t\t\t\tErr(_) => (),\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttrue\n@@ -61,6 +118,5 @@ pub fn Fn(\n\tOk(Difference)\n}\n\npub struct Option {\n\tpub Omit: Vec<String>,\n}\nuse rayon::prelude::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\ndiff --git a/Source/Struct/mod.rs b/Source/Struct/mod.rs\nindex a56e8ce..4ca5f2b 100644\n--- a/Source/Struct/mod.rs\n+++ b/Source/Struct/mod.rs\n@@ -1 +1,2 @@\npub mod Binary;\npub mod Summary;\ndiff --git a/Source/Struct/Summary/Difference.rs b/Source/Struct/Summary/Difference.rs\nnew file mode 100644\nindex 0000000..7583a0a\n--- /dev/null\n+++ b/Source/Struct/Summary/Difference.rs\n@@ -0,0 +1,3 @@\npub struct Struct {\n\tpub Omit: Vec<String>,\n}\ndiff --git a/Source/Struct/Summary/mod.rs b/Source/Struct/Summary/mod.rs\nnew file mode 100644\nindex 0000000..7241509\n--- /dev/null\n+++ b/Source/Struct/Summary/mod.rs\n@@ -0,0 +1 @@\npub mod Difference;\n", "üó£\u{fe0f} Summary from tag: Summary/v0.0.4 to tag: Summary/v0.0.5:")}
